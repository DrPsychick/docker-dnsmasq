language: bash
services: docker

env:
  global:
  - IMAGE=drpsychick/docker-dnsmasq
  matrix:
  - ALPINE_VERSION=edge
  - ALPINE_VERSION=3.8
  - ALPINE_VERSION=3.7
  - ALPINE_VERSION=3.6

before_script:
  - docker build -t dnsmasq-test --build-arg ALPINE_VERSION=$ALPINE_VERSION .
  - VERSION=$(docker run --rm dnsmasq-test --version |awk '$2 == "version" { print $3; exit }')
  #- alpine_version=$(docker run --rm --entrypoint cat dnsmasq-test /etc/alpine-release)

script:
  # test always passes
  - echo "Alpine $ALPINE_VERSION Dnsmasq $VERSION"
  - >
    echo "Running tests...";
    docker run dnsmasq-test --version

#after_script:
#  # trigger dockerhub build (only for master)
#  # misuse travis-ci cron to keep latest docker image up to date
#  - >
#    if [ "$(git rev-parse --abbrev-ref HEAD)" == "master" ]; then
#      curl -X POST "$DOCKERHUB_TRIGGER";
#    fi

# Option A: give docker credentials to Travis -> docker images can be compromised, only one 'master' user! -> does not scale
#before_deploy:
#  - docker login -u "$REGISTRY_USER" -p "$REGISTRY_PASS"

# Option B: use github token -> separate, restricted access, but public repos can be compromised -> more complicated, but scales

# Option C: use github deploy keys -> SSH keys, per repo -> best security, scales
after_success:
  # tag = $dnsmasq_version-alpine$alpine_version (e.g. 2.80-alpine2.8.0)
    #test $TRAVIS_BRANCH = "master" && {
  - >
    if [ "$ALPINE_VERSION" == "edge" ]; then branch="$VERSION"; else branch="${VERSION}-alpine${ALPINE_VERSION}"; fi;
    exists="$(test -n "$(git branch -r |grep "$branch")" && echo "yes")";
    echo "Branch: $branch ($exists)";
    git branch $branch;
    sed -i -e "s/ALPINE_VERION=.*/ALPINE_VERSION=$ALPINE_VERSION/" Dockerfile;
    docker build -t $IMAGE:$branch --build-arg ALPINE_VERSION=$ALPINE_VERSION .;
    docker run --rm --entrypoint /bin/sh $IMAGE:$branch -c 'cat /etc/alpine-release; dnsmasq --version';
    cat Dockerfile;
    git branch;
